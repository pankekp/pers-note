# 排序

---

## 1. 冒泡排序

**原理**：每次比较相邻两个元素，不符合大小关系就交换。一次冒泡至少会令一个元素排序完成

**空间复杂度**：属于原地排序，O(1)

**时间复杂度**：最好情况下数据有序，一次冒泡即可完成排序，为 O(n)；最坏情况下数据倒序，每次冒泡需要交换 n 次，为 O(n^2)

**稳定性**：冒泡排序中只有交换操作会改变两个元素的顺序，为了保证稳定性，当相邻元素大小相同时不交换即可，所以冒泡排序是稳定的

## 2. 插入排序

**原理**：插入排序将序列分为已排序区间和未排序区间，然后取未排序区间的元素反向与已排序元素比较，找到合适位置，将插入点之后元素后移一位，插入元素即可

**空间复杂度**：属于原地排序

**时间复杂度**：最好情况下数据有序，遍历一边即可，为O(n)；最坏情况下数据倒序，每次插入都是在已排序区间的队头，为O(n^2)

**稳定性**：可以将元素插入已排序区间中值相同元素的后边，保持原有顺序不变，所以是稳定排序

## 3. 选择排序

**原理**：将序列分为已排序区间和未排序区间，每一次选择中将最小元素与未排序区间的第一个元素交换，则已排序区间会从小到大增长

**空间复杂度**：属于原地排序

**时间复杂度**：均为O(n^2)，因为无论序列是否有序，每次选择都需要遍历未排序区间

**稳定性**：每次选择都会和前边的元素交换，如果交换的两个元素中间存在值相同的元素，值相同元素的相对顺序被破坏了，所以不是稳定排序

## 4. 归并排序

**原理**：将序列分为两段，递归地进行排序，由于最终会被分解为两个元素比较，所以终止条件就是两个元素比较，满足顺序即返回；然后将递归排序完毕的两段序列进行 merge，借助从子序列 low 及从 mid+1 开始的双指针，两两对比即可按照大小要求完成排序

```java
private static Comparble[] temp;

public void sort(Comparble[] array){
    temp = new Comparble[array.length];
    sort(0, array.length - 1, array);
}

private void sort(int lo, int hi, Comparble[] array){
    if(lo > hi){
        return;
    }
    int mid = lo + (hi - lo) / 2;
    sort(lo, mid, array);
    sort(mid + 1, hi, array);
    merge(lo, mid, hi, array);
}

private void merge(int lo, int mid, int hi, Comparble[] array){
    int i = lo, j = mid + 1;
    for(int k = lo;k <= hi;k++){
        temp[k] = array[k];
    }
    for(int k = lo;k <= hi;k++){
        if(i > mid){
            array[k] = temp[j++];
        }else if(j > hi){
            array[k] = temp[i++];
        }else if(less(temp[i], temp[j])){
            array[k] = temp[i++];
        }else{
            array[k] = temp[j++];
        }
    }
}
```

**空间复杂度**：不属于原地排序。即使使用了递归的方式，任意时刻 CPU 只会执行一个函数，而且 merge 操作后临时开辟的空间也会被释放，其最大不会超过序列大小，所以为 O(n)。

**时间复杂度**：任何情况下均为 O(nlogn)。

**稳定性**：归并排序的中移动元素的操作在 merge 中，所以在 [lo,mid] 及 [mid+1,hi] 两段子序列中，将前者中的元素先存入临时数组，这样在出现值相同的情况时，合并前后顺序不变，所以是稳定排序。

## 5. 快速排序

**原理**：与归并类似，使用切分元素将序列分为两个区间，一般选定序列首元素或尾元素作为切分元素，使用双指针从两端进行遍历，保证指针走过的元素分别小于和大于切分元素，交换不符合条件的元素，指针相遇的位置为当前切分元素在序列中排定的位置。

```java
public void sort(Comparable[] array){
    sort(0, array.length - 1, array);
}

private void sort(int lo, int hi, Comparable[] array){
    if(lo > hi){
        return;
    }
    int j = partition(lo, hi, array);
    sort(lo, j - 1, array);
    sort(j + 1, hi, array);
}

private int partition(int lo, int hi, Comparable[] array){
    int i = lo, j = hi + 1;
    Comparable v = array[lo];
    while(true){
        // 注意是 ++i 不是 i++，因为 i 位置是 v
        while(less(array[++i], v)){
            if(i > hi){
                break;
            }
        }
        while(less(v, array[--j])){
            if(j < lo){
                break;
            }
        }
        // 跳出以上两个循环也可能是因为 i 和 j 走到尽头
        // 所以需要先判断
        if(i >= j){
            break;
        }
        swap(i, j, array);
    }
    // 跳出循环到此说明序列中的元素根据相较于 v 已经分为两部分
    swap(lo, j, array);
    return j;
}
```

**空间复杂度**：属于原地排序。

**时间复杂度**:在极端情况下，如序列本身就是有序的，partition 会极其不均衡，时间复杂度此时会退化至 O(n^2)；在理想情况下，每次 partition 都将序列一分为二，此时时间复杂度为 O(nlogn)。

**稳定性**：类似选择排序，元素会被交换，所以不是稳定排序。

**查找序列的第k大元素**：借助快排中切分元素会被移动至排定位置的特性，根据切分元素位置和 k 的大小关系查找，比如在从小到大排序中，(n-k) 是第 k 大元素的下标，那就需要将 (n-k) 位置的元素排定。当 j < (n-k) 时，说明此时排定的元素在目标位置的左侧，应该将区间缩小至 [j+1,hi] 再次查找。

## 6. 桶排序

**原理**：将数据分散到若干个**有序**的桶中，每个桶中的数据再排序。桶内排序完毕后，按照桶的顺序将桶内数据有序取出，形成的序列即为有序序列。

**空间复杂度**：不属于原地排序，需要额外的桶空间，为O(n\*k)。

**时间复杂度**：如果要排序的数据有 n 个，将其均匀地划分到 m 个桶中，每个桶中 n/m 个元素，桶内使用快排，m个桶需要 O(m\*k\*logk)，有 k=n/m，所以桶排序时间复杂度为 O(n\*log(n/m))，当桶的个数 m 接近元素个数 n 时，log(n/m) 接近一个非常小的常量，此时桶排序时间复杂度接近 O(n)，属于线性排序。

**稳定性**：单个桶内使用归并可保证稳定性。

**适用场景**：桶排序时间复杂度接近线性的前提是待排序序列分布均匀，这样每个桶中元素的个数才能近似。

## 7. 堆排序

**原理**：

1. 建堆：由于完全二叉树的特性，**从下标为 1 的位置开始存储元素时，$[2n, 2n + 1]$ 都是叶子节点**，从后向前对每一个非叶子节点进行下沉操作，最终可形成大顶堆
2. 排序：由于堆顶元素为最大元素，将堆顶元素与 n 位置元素交换并下沉新堆顶元素，则最大元素排序至末尾；此时堆顶为第二大元素，与 n-1 位置元素交换。重复此过程即可完成排序

**空间复杂度**：属于原地排序。

**时间复杂度**：建堆与排序过程的主要操作均是恢复堆的有序性，所以整体时间复杂度为 $O(log_{2}n)$。

**稳定性**：排序过程中涉及到堆顶元素和末尾元素的交换，可能改变值相同元素的相对顺序，所以不是稳定排序。

**与快速排序对比**：二者都是原地排序，且时间复杂度相同，但是实际中仍然是使用快速排序更多

* 快速排序中多为局部的顺序访问，而堆排序并不是连续访问顺序元素，对 CPU 缓存不友好
* 堆排序的数据交换次数比快排多

## 8. 外部排序

8GB 数据 / 2GB 内存：

**双路归并**：加载 4 次数据，得到 4 * 2GB 的有序数据；两两序列 merge，需要 merge 三次，每次分别读取一个数据，比较后输出到外部磁盘。

**多路归并**：每次从 n 个序列中各读一个数据，在内存中从 n 个数中找到最小的，输出到磁盘。过大的 n 会导致内存中查找最小数时间上升。

**置换选择**：在多路归并的基础上考虑减少有序子串的个数，也就是说**使用 2GB 的内存排序出大于 2GB 的有序子串**，使用置换选择算法

1. 读取 2GB 数据内存中，构建小顶堆，将堆顶元素写入序列 1
2. 读取一个数据：
   * 如果此数据大于之前的写入序列 1 的元素，则再次加入堆中，恢复的有序性，将堆顶元素再次写入序列 1，这次写入的元素一定大于序列 1 已写入的元素
   * 如果此数据小于之前的写入序列 1 的元素，若将此数据加入堆后，此数据会成为小顶堆堆顶，写入序列 1 会打破序列 1 的有序性（这里认为数据是顺序写入文件，新写入的元素会小于之前写入的元素），所以将此数据剥离最小堆暂存，堆大小减 1

3. 完成序列 1 （也就是堆大小减为 0）后将暂存的数据再次构成堆，重复上述步骤构建序列 2

最好情况下所有数据形成 1 个子串，最坏情况下相当于此算法未生效，获得子串的平均大小为工作内存的两倍（扫雪车模型证明）。

**位图**：顺序读取文件，将数字对应的位图位置 1，从小到大输出位图元素为 1 的下标即可。如果出现重复数字，可以考虑维护一个散列表，记录重复的数字和个数。

**桶排序**：先扫描一边外部数据，按照得到的数据范围划分为若干个桶，每个桶对应一个文件，将数据分别写入这些桶中，再将每个桶中的数据加载至内存排序，最后按照桶的顺序将数据汇总即可。

# 面向对象

---

## 1. main

在不考虑其他容器管理的 Java 程序的情况下：

* static：main() 是 Java 程序的入口方法，static 通过将 main() 标记为类的方法，便于 JVM 识别，可以通过类名直接访问，不用创建对象
* void：由 JVM 调用无需返回值
* public：入口方法理应被暴露出来

## 2. 构造方法 & 构造块

**构造方法可以调用该类的其他构造方法**：使用 this 且必须在构造方法体第一行使用，因为初始化动作需要先执行，否则可能会覆盖此构造方法传入的值。

**构造方法可以调用该类的成员方法**：该成员方法必须是 private 或 final 的。考虑以下情况：

* 新建子类对象访问父类构造，父类构造调用成员方法，由于多态会访问子类中重写的方法，但此时子类成员变量只初始化了默认值，还未实例化，无法访问显式赋值的结果
* 如果构造中调用的方法是无法被重写的，则不会出现这种情况

构造代码块相比与构造方法，它是**对全体对象都能产生作用**。

## 3. static

修饰成员变量：在内存中只有一份并且被该类所有对象共享

修饰类：只能作为内部类

## 4. final

关闭多态，提升性能，但是一般对程序整体性能不会有什么改观，所以一般从设计角度考虑 final 适用与否：

* 方法：不允许被重写
* 类：不能被继承，同时final类的域及方法默认final
* 变量：编译时赋值，一旦被分配内存就必须初始化。也就是说对于在类加载阶段就分配内存的类变量（final static）来说，可以在定义时赋值或静态块中赋值；而对于在实例化阶段才分配内存的实例变量来说，则是必须在定义中赋值或构造方法中赋值
* 形参：只能读取但不能修改，一般用于向匿名内部类传参

## 5. 内部类

Java 中的闭包：

* 外部环境持有内部函数所使用的自由变量，那么外部环境对内部函数构成闭包，其中自由变量在函数中既不是形参也不是局部变量
* 在 Java 中，一个类的成员方法引用了成员属性，此成员属性属于此成员方法的自由变量，也就是说这个类对它的成员方法构成了闭包，成员方法通过 this 访问到成员属性

Java 中的内部类只是一个编译时概念，编译后是两个完全不同的类：

* 可以将内部类看作一个外部类的成员，所以可以使用多种权限修饰
* 内部类是 Java 闭包的一种体现，内部类包含一个指向外部类的引用，所以可以自由访问外部类中的任意成员属性，变相的把环境中的自由变量封装到方法中形成闭包

成员内部类：

* 内部类可以访问外部类中任意权限成员
* 外部类访问内部类成员需要创建内部类对象，可以访问内部类任意权限成员，考虑外部类为 Stack，内部类为 ListNode 的情况
* 创建成员内部类的对象前必须存在外部类的对象，与其他成员一样不能创建 private 修饰的成员内部类

静态成员内部类：

* 相当于一个**独立的外部类**，可以直接通过外部类名访问内部类
* 静态内部类只能访问外部类的静态成员，因为不持有指向外部类的引用
* 普通内部类不能持有 static 成员，也不能包含静态内部类，但静态内部类不受以上约束
* 同成员内部类，外部无法访问 private 修饰的静态内部类

普通成员内部类和静态成员内部类的很大区别在于前者可以访问外部类所有成员（包括静态成员），而后者只能访问外部类的静态成员，所以从设计角度考虑，静态内部类偏向于降低包的深度，方便管理类结构，和外部类耦合并不紧密；而后者建立的目的是某些属性主要给外部类使用，所以封装称内部类的形式。

局部内部类：

* 类似成员内部类，但是访问范围仅限方法内或该作用域内
* 相当于局部变量，不能带有权限及 static

匿名内部类：

* 需要继承父类或实现接口但临时调用一次，没有必要写成单独一个类，使用匿名内部类的形式
* 由于匿名所以无法持有构造方法，但可以通过构造代码块实现类似构造方法的效果

**区分匿名内部类和 lambda 表达式**：匿名内部类的 this 指向内部类，而 lambda 表达式中的 this 指向调用它的对象。

```java
public class Hello{

    private Hello hello = this;

    Runnable r1 = new Runnable() {
        @Override
        public void run() {
            System.out.println((Object) this == hello);
        }
    }

    Runnable r2 = () -> System.out.println(this == hello);
}

new Hello().r1.run();// false
new Hello().r2.run();// true
```

内部类与 final：局部内部类与匿名内部类只能访问被 final 修饰的局部变量或形参。

```java
interface Inner(){
    addXYZ();
}

public class Outer{
    public Inner getInner(final int x){
        final int y = 100;
        return new Inner(){
            int z = 100;
            pubilc int addXYZ(){
                return x+y+z;
            }
        }
    }
}
```

* 成员方法与内部类的生命周期不同，方法执行结束内存会被释放，局部变量也就不复存在了，而内部类可能仍然存在，不会随着方法结束运行而死亡
* 内部类使用的是外部局部变量的一个副本，为了保证内外数据一致性，使用 final 修饰使其只读

需要注意的是内部类访问成员属性不需要 final 修饰，因为**内部类持有指向外部类的引用，导致外部类始终被引用而不会被 GC**，从而可以访问到其成员属性，而这一点会导致内存泄漏，可以使用静态内部类使内部类不持有外部类的引用。

## 6. 继承

特性：

* 子类可访问父类全部的非 private 成员
* 对于同名属性，子类默认隐式使用 this 自身调用
* 子类使用 super 调用父类同名属性
* 子类所有的构造方法第一句都存在隐式 super()，默认调用父类的空参构造方法，原因是继承时子类已经可以访问父类的非private成员，这意味着在子类中必须使父类成员有效，而对于private的父类成员属性子类无权访问，只有父类自己的构造方法才能进行对象的正确初始化，所以必须令所有构造方法都能得到调用才能构造完整的对象

需要注意的是，**静态属性和方法是可以继承的，但是无法被重写**，因为对它们的调用不需要通过继承机制。

## 7. 抽象类

* 含有抽象方法，可以拥有普通的成员变量与成员方法（模板方法模式），即含有抽象方法的类一定是抽象类
* 也可以不含抽象方法，如对接口的空实现（HttpServlet），为了让其他类继承
* 可以存在构造方法，给子类对象初始化使用
* 不可以与以下关键字共存：
  * final：final 修饰的类不允许被继承
  * private：private 会使抽象方法不能被覆盖
  * static：静态调用抽象方法无意义

## 8. 接口

* 属性：public static final
* 方法：public abstract

## 9. 多态

认识：Java 的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态，即通过使用一个父类型的变量来引用一个子类型的对象，根据被引用子类型的不同得到不同的运行结果。

实质：**子类对象的转型**

* 向上转型：父类引用指向子类对象，子类对象提升为父类型，但不能使用子类特有方法
* 向下转型：父类引用指向子类对象时，为了使用子类的独有方法，将提升为父类型的对象强转回为子类型

同名成员调用：

* 同名属性：属性不具备多态性，跟随对象类型
* 同名方法：
  * 编译阶段只能调用其编译时类型所具有的方法，运行时执行它对象中所具有的方法
  * 若在同名方法中访问同名成员变量，则成员变量为运行时类型的变量，因为方法属于对象，其会访问自己对象中的值
* 同名静态方法：
  * 由于静态方法调用不需要对象，所以其编译与运行时均访问父类方法
  * 同理，若静态方法中访问同名静态成员属性，访问的是也是编译时类型对应的属性

绑定：

* 静态绑定：在程序执行前也就是编译过程中就绑定到类上，如对方法的重载
* 动态绑定：虚拟机将调用对象实际类型所限定的方法，如对方法的重写

协变返回类型：子类中进行重写的父类方法可以返回父类方法返回类型的子类。

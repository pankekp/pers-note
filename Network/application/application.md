# 应用层

---

## 1. DHCP

动态主机配置协议（Dynamic Host Configuration Protocol）用于为本网段的主机动态分配IP地址，可以认为是DHCP的服务器会配置一段共享的IP地址，每台新接入的主机通过DHCP协议在这一段共享IP地址中申请一个IP。当主机离开本网段时将IP地址归还供其他主机使用

**DHCP过程**：

1.DHCP Discover：只有MAC地址，在网段内广播

| 源MAC   | 目标MAC           | 源IP    | 目标IP          | 内容            |
| ------- | ----------------- | ------- | --------------- | --------------- |
| 主机MAC | ff:ff:ff:ff:ff:ff | 0.0.0.0 | 255.255.255.255 | 提供MAC并申请IP |

2.DHCP Offer：只有MAC地址唯一才会正确分给主机IP并保留此IP不分给其他主机。同时DHCP服务器回复时仍需要使用广播，因为此时主机还未被分配IP

| 源MAC         | 目标MAC           | 源IP         | 目标IP          | 内容                     |
| ------------- | ----------------- | ------------ | --------------- | ------------------------ |
| DHCP服务器MAC | ff:ff:ff:ff:ff:ff | DHCP服务器IP | 255.255.255.255 | 主机MAC与预分给此MAC的IP |

3.DHCP Request：选择一个DHCP Offer并发送DHCP Request，告诉所有DHCP服务器自己将接受哪台服务器的分配的IP，告诉其他DHCP服务器请求撤销预分配的IP

| 源MAC   | 目标MAC           | 源IP    | 目标IP          | 内容                                  |
| ------- | ----------------- | ------- | --------------- | ------------------------------------- |
| 主机MAC | ff:ff:ff:ff:ff:ff | 0.0.0.0 | 255.255.255.255 | 提供MAC与即将接受哪个服务器预分配的IP |

4.DHCP ACK：DHCP服务器接受主机的选择，将IP的合法租用信息及相关数据广播，让其他主机也得知

| 源MAC         | 目标MAC           | 源IP         | 目标IP          | 内容                                  |
| ------------- | ----------------- | ------------ | --------------- | ------------------------------------- |
| DHCP服务器MAC | ff:ff:ff:ff:ff:ff | DHCP服务器IP | 255.255.255.255 | ACK、分配IP的DHCP服务器及IP的相关信息 |

## 2. HTTP

**特点**：HTTP 协议基于 TCP 协议，并且是无状态的，也就是说服务器不保存任何客户端的信息，客户端访问服务器的连续性由 cookie / session 维护

**GET / POST**:

* HTTP协议规定Method与应用层数据传输方式无关，更没有要求数据需要放在URL或body中，常见的约定是基于HTML标准
* HTTP协议对GET和POST没有长度限制，而对URL的长度限制是防止服务器负担过大以及避免恶意访问
* GET相比POST具有幂等性
* POST相对比GET更安全，因如果HTTP请求完数据就关闭连接，GET请求一般会被浏览器缓存的。但POST请求不被用户发现不能代表就比GET安全，这与浏览器的实现有关

**改进**：

* **长连接**：1.1相比1.0引入了keep-alive机制，TCP连接默认不关闭，也就是说HTTP协议的长连接实质上是TCP协议的长连接
* **队首阻塞**：对于同一个TCP连接，1.0中会将所有请求放入队列，只有前一个请求的响应收到后才会发送下一个，会导致客户端的队首阻塞。在1.1中允许在一个TCP连接中发送多个请求，解决了客户端的队首阻塞，但是服务端响应的发送需要按照请求被接收的顺序排队，单个响应处理慢会导致服务端队首阻塞。在2.0中由于一个TCP连接被切分成多个stream，可以双向通信，互相独立，避免了队首阻塞问题
* **头信息压缩**：2.0相比1.1在两端使用索引表，使用索引代替头信息
* **帧数据**：2.0相比1.1将所有信息分割为不同类型的帧并使用二进制编码。通过将多个请求进行分流，再降请求拆分为帧，在服务端根据帧首部的流标识，针对不同类型的帧进行重组，提高解析效率

## 3. HTTPS

HTTP 的不足：

* 明文通信
* 无法验证通信双方的身份
* 无法验证报文完整性

### 3.1 报文加密

对称加密：加密解密使用同一个密钥，但密钥存在泄露的可能性，无法保证密钥的安全传输。

非对称加密：加解密的密钥不同，使用公开的公钥以及私有的私钥，**公钥加密只能使用私钥解密**。

### 3.2 验证报文完整性

**数字签名**是附加在数据上一段加密过的数据校验码：

* 可以证明作者：由作者的私钥生成
* 防止数据被修改：修改后的数据的校验和会发生变化

### 3.3 验证身份

数字签名的漏洞：如果数据接受者的公钥被攻击者替换，则攻击者则可以使用自己的私钥向此用户发送数据，而**数字证书的引入就是为了保证公钥的真实性**。

如何借助数字证书验证对方发送的公钥的真实性？

1. 客户端接收到的数字证书会附带证书颁发机构（CA）的数字签名
2. 各大 CA 的公钥默认安装在操作系统中
3. 客户端使用 CA 的公钥验证证书的完整性，通过验证则说明证书无误，使用证书中的公钥即可

### 3.4 HTTPS

SSL（Secure Sockets Layer）：一种使用加密、数字签名、数字证书的机制。不同的是由于**非对称加密的性能不如对称加密**，所以 SSL 只在建立连接时使用非对称加密，数据的传输则采用对称加密。

TLS（Transport Layer Security）：传输层安全协议，SSL 的改进版，习惯上将这两者都称为 SSL。

HTTPS：HTTP + SSL

1. 用户向服务器 443 端口发起请求
2. 服务端返回证书，证书中包含服务端的公钥
3. 客户端通过证书管理器得到 CA 的公钥来验证证书完整性，并取得服务端的公钥
4. 客户端使用得到的公钥加密后续数据传输使用的对称加密的密钥
5. 服务端使用私钥解密后得到对称加密的密钥，此时双发即可使用对称加密进行数据传输

## 4. DNS

**特点**：

* 由分层的DNS服务器实现的高可用、高并发、分布式的数据库
* 基于UDP协议

**架构**：

![dns layer](image/dns_layer.jpg)

**查询**：

![dns search](image/dns_search.jpg)

# 传输层

---

## 1. UDP

无连接，减少时延传输简单

可以一对多，多对一，多对多，可承载广播或多播协议

尽最大努力交付，但不保证交付

面向报文，容易区分，避免粘包拆包

传输快，无拥塞控制

适用于丢包不敏感、需要广播、处理速度快不关心拥塞的环境下使用：

* 基于UDP的应用层协议QUIC
* 注重实时性、直播中使用的流媒体协议，快速重传而不是主动让步
* 网络游戏
* IoT，终端资源少不适合维护复杂协议，且实时性要求高

## 2. TCP

**连接**：客户端与服务端为了维护连接，在双方建立一定的数据结构来维护双方交互的状态，以此来保证面向连接的特性

### 2.1 连接管理

![tcp establish](image/tcp_establish.jpg)

**三次握手**：

* 至少经过通信三次客户端与服务端才能得知自己与对方分别是收发正常的
* 确认TCP包的序号。客户端与服务断需要分别告诉对方自己发送的包的起始序号，需要注意的是**每次连接的序号都是不同的**，并不是从1或固定的数字开始，而是随着时间变化而变化的，可以看成一个32位计数器，出现重复的时间间隔远远大于包TTL耗尽的时间，这样就防止了失效或延迟的连接请求传送到服务器而产生错误

![tcp close](image/tcp_close.jpg)

**四次挥手**：由于TCP全双工的原因，客户端发送断开连接的请求只表示自己不再发送数据，而连接的完全关闭需要服务端也不再向客户段发送数据，相比建立连接，服务端需要多发送一次请求

**TIME-WAIT**：

* 在客户端最后发送确认关闭连接的请求后，如果服务端收不到此请求，则会重复发送关闭连接的请求，为了保证连接正确关闭，客户端会等待2MSL以保证有机会弥补上一个请求丢包的情况
* 如果客户端在发送完确认关闭连接的请求后直接关闭连接，此时端口会被让出，一旦其他应用再次占用，服务端就会在不知情的情况下继续给此端口发送数据，所以等待2MSL（MSL为报文最大生存时间），保证连接过程中所有的包都消失后再关闭连接让出端口

### 2.2 Advertised Window

为了在传输过程中不发送超出接收端接受收能力的数据，接收端会为发送端提供一个 Advertised Window 来控制发送端的发送行为，发送端需要维持如下的数据结构，其中黑框区域即为根据接收而**在发送端划定的 Advertised Window**：

![advertised window send](image/advertised_window_send.jpg)

接收端需要维护的数据结构如下：

![advertised window rec](image/advertised_window_rec.jpg)

**接收端的黑框区域表示最大缓存量（MaxRcvBuffer）**，其中`Advertised Window = MaxRcvBuffer - (NextByteExpected - LastByteRead)`

### 2.3 可靠传输

**累计确认**：每一个包拥有一个ID，为了保证不丢包，对于发送的包需要进行应答，但并不是对每一个包都进行应答，而是应答某个ID，表示这个ID之前的包均已收到

**超时重传**：

* 在等待接收区域中，包到达的顺序可能是乱序的，只有和已确认接收部分连续的包才能发送确认，空缺位置后的包尚不可确认到达，所以对于发送了但没有收到ACK的包，在一定时间后重新发送
* 超时时间会根据网路状况等不断变化，每经过一次超时重传就会将超时时间加倍，但会导致发送间隔过长的问题，可以采用**快速重传**的机制，即当接收到一个包，其序号大于下一个所期望包的序号时，说明在等待接受区域中出现了可能空缺，则连续发送三个空缺前位置包的ACK，ACK中包含接收端需要的包，发送端检测到会立即重发，不会在等待超时时间

### 2.4 流量控制

流量控制就是接收端通过在ACK中告知发送端自己Advertised Window的大小，从而控制发送端的发送速率，防止发送端将接收端缓存塞满

1. 当窗口大小不变时，发送端收到了一个ACK，窗口右移，未发送可发送部分大小+1，此时发送端将未发送可发送部分全部发送，LastByteSent右移，未发送可发送部分为0。此时只有收到所期望的下一个包的ACK时，窗口才会再次右移，未发送可发送部分大小变为1
2. 假设极端情况，接收端的应用始终不读取已确认过的包，此时收到一个包后，NextByteExpected右移，窗口大小-1。新的窗口大小被发送端接收后，发送端LastByteAcked右移，保证窗口大小-1，与接收到的新的窗口大小一致
3. 发送端窗口大小为0时则停止发送
4. 接收端直至发送窗口达到一定大小后再向发送端更新窗口大小

### 2.5 拥塞控制

目的是在网络不堵塞、不丢包的情况下最大限度使用带宽

拥塞控制由拥塞窗口cwnd与滑动窗口rwnd（Advertised Window）共同控制，有```LastByteSent - LastByteAcked <= min(cwnd,rwnd)```

一般发送端察觉到丢包需要超时重传时即认为网络发生了拥塞，需要调整发送速度

**慢启动**：

1. 发送开始前无法得知网络状况，无法确定cwnd大小，则需要从小的数值进行试探
2. 初始将cwnd置为1，一次发送一个包，收到ACK后cwnd+1；此时可以一次发送两个包，每个ACK都令cwnd+1。可以看出呈指数性增长
3. cwnd达到阈值后变为线性增长
4. 检测到丢包需要超时重传时，将阈值设为cwnd/2，将cwnd设为1

**快恢复**：当只丢失一个中间包，即可以采用快速重传时，认为拥塞不严重，只会将阈值设为当前cwnd，cwnd减半

### 2.6 粘包

粘包就是收到的报文段要么不完整，要么多了一部分。常见的原因有：

* 当报文段超出最大限制，TCP会进行拆包
* 要发送的数据大于发送端未发送可发送区域大小，导致包不完整
* 接收端没有及时读取已确认的数据导致报文段数据异常

解决：发送时附加数据长度、封装固定大小的数据包、设置边界以便于拆包

## 3. 可靠 UDP

通过在应用层模拟 TCP 的可靠传输来实现 UDP 的可靠传输。

* 仿照 TCP 添加 seq 机制，双方设定包的发送序号
* 接收端接收包后需要发送 ACK 确认
* 发送方在一定时间内没有收到 ACK 则重新发送该包

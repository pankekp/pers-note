# 死锁

---

## 1. 死锁必要条件

**互斥**：资源要么已经分配给了进程，要么是可分配的。

**占有和等待**：已经得到资源的进程可以再次请求资源。

**不可抢占**：已经被分配给进程的资源不能被其他进程抢占，只能等待被释放。

**环路等待**：有两个及以上的进程组成环路，其中每个进程都在等待下一个进程释放资源。

## 2. 处理方法

**检测并恢复**：不试图阻止死锁，而是当检测死锁后进行恢复：

* 检测：进程请求资源路径中是否存在环，从一个节点出发进行深度优先搜索，标记访问过的节点，如果再次访问到了标记过的节点，则说明存在环（wait-for graph）
* 恢复：回滚或杀死进程

**避免**：使用某种策略避免运行时发生死锁。

## 3. 死锁场景

### 3.1 Java 中的死锁

线程互相持有锁，但继续执行却需要获取对方的锁，导致程序执行无法继续。

可以采用一些方式避免这种情况：

* 不要嵌套锁，如果需要嵌套就全局指定一个嵌套顺序
* 使用具有超时机制的锁

### 3.2 数据库中的死锁

与 Java 类似，两个事务对记录或表加锁，但是后续的操作需要操作对方的正在使用的记录或表，也需要加锁，就造成了互相等待对方释放锁的情况。

* 处理：
  * 避免：可以在两个事务中使用同样的加锁顺序
  * 检测并恢复：如果事务执行超时则撤销重新执行

另外就是由于 InnoDB 索引的关系，更新数据时使用行锁，所以执行 UPDATE 时，如果用到了主索引，就会锁住主索引；如果用到了二级索引，就会先锁住二级索引，再锁住主索引。

如果一张表主键是 id，而 user_id 建立了索引：

```sql
update xxx set col=xxx where user_id=？;
```

上面这条语句使用到了二级索引，所以会先对二级索引加锁，然后对主索引加锁。如果在二级索引和主索引加锁之间执行另一句 SQL：

```sql
update xxx set col=xxx where id=? and user_id=?;
```

这条语句会先锁住主索引，然后锁住二级索引。

此时第一条 SQL 已经锁住了二级索引，准备对主索引加锁；而第二条 SQL 已经锁住了主索引，等待对二级索引加锁，又出现了互相等待锁的情况。

* 处理：
  * 避免：对于第一条 SQL，先查询出符合更新条件的行，然后逐条更新，这样两条 SQL 语句都一定会先锁住主索引，也就是指定了加锁顺序

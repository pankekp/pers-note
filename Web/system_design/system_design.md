# 系统设计

---

## 1. 幂等性

常见的一些场景：由于网络故障发送的多条重复消息接收方实际直接收到一条、多次的付款实际只进行一次扣款，这些都是系统幂等性的体现。

也就是说**接口在使用重复参数请求多次时，不会影响系统的状态**，而在分布式系统中，由于天然的时序问题，以及网络的不可靠性，重复请求很常见，所以接口的幂等性设计就显得尤为重要。

另外，HTTP 协议中，相比于 POST、PUT、DELETE，GET 就是具有幂等性的。

如何保证幂等性？

就支付订单这种情况来说，幂等性可以使用唯一单号保证：

1. 先查询订单是否已经支付
2. 如果支付则返回成功，否则进行支付流程，并在支付成功后修改支付状态为已支付

需要注意的是，这里涉及到的两个步骤必须要保证原子性，因为第二步依赖第一步的结果，否则在高并发下如果在支付成功但还未修改支付状态时到达其他请求，就会误判为未支付。

对于如何解决上述问题的原子性，最直接的就是加锁，阻塞锁、CAS，以及借助[分布式锁](../distribution/distribution.md#lock)等。

## 2. 消息队列

消息队列一般有三种应用场景：

* 解耦：多个子系统间加入消息队列这种中间件，即使一方进行的大幅的变动，或功能故障，只要能提供相同的消息或队列中还存在消息，都不会影响和他对接的子系统
* 异步：提高系统响应时间，如注册后发送通知的操作就可以在写完数据库后通过队列异步执行
* 削峰：高并发下通过队列控制请求处理速度或限制队列长度来减少无效的请求

但加入消息队列会降低系统可用性：队列的故障会影响系统；也会加大系统复杂度：需要考虑消息不被重复消费、消息可靠传输等问题。

### 2.1 RabbitMQ

![rabbit mq](img/rabbitmq.png)

RabbitMQ 是 AMQP 协议的一个实现，有几个需要注意的点：

* Message：消息的消息头包含 routing-key
* Exchange：交换器，用来接收生产者的消息并按照一定的规则发送给队列，可以将交换器理解为一种路由器，队列通过 key 和交换器绑定
* Channel：信道，多路复用连接中的一条独立的双向数据流通道，建立在真实的 TCP 连接内。不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为建立和销毁 TCP 是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接

交换器类型：

Fanout：

* 所有发送到这种交换器的消息都会被直接转发到绑定的队列上
* 不需要处理 routing_key，所以转发消息是最快的，适用于需要随时改动业务处理队列的场景

Direct：

* 消息被转发到绑定了指定 key 的队列上
* 适用于有优先级的任务，根据任务的优先级把消息发送到对应的队列

Topic：

* 可以认为在 Direct 的基础上，队列绑定的 key 能够匹配多个 routing-ley
* 适用于消息需要基于多个条件进行路由的场景，如日志系统，不仅根据日志的级别而且根据日志的来源进行订阅
  
Headers：匹配消息头而不是 routing-key，和 Direct 类似，但性能不如 Direct

### 2.2 消息的重复消费

正常情况下，消费者在消费消息完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除，因为网络故障等原因队列没有收到确认消息，导致重复发送消息给消费者：

* 借助数据库使用唯一索引
* 给消息分配全局 id，消息被消费后就写入 Redis，消费前查询 Redis

这个问题本质上需要**保证消费者调用的业务接口的幂等性**。

### 2.3 消息的可靠传输

针对 RabbitMQ：

生产者丢数据：

* 使用 AMQP 事务：发送消息过程中出现异常则进行回滚，发送成功则提交事务，但会导致吞吐量下降
* 开启 channel 的 confirm 模式：
  * 消息被指派一个唯一 id，一旦消息被投递到匹配的队列之后，队会发送一个 ACK 给生产者（包含消息的唯一 id），使得生产者确认消息已经正确到达目的队列
  * 如果没能处理这个消息，会回调生产者的一个接口，告诉消息写入失败
  * 如果超过一定时间没接收到这个消息的回调，生产者可以进行重发

需要注意的是，事务方式是同步的，而使用 ACK 则是异步的，吞吐量更高。

队列丢数据：

* 消息持久化

消费者丢数据：

* 手动确认：一般是因为采用了自动确认消息的模式，消费者会自动确认收到信息，消息队列会立即将消息删除，这种情况下如果消费者收到消息但出现异常而没能处理该消息，消息队列就会丢失该消息。可以在消费者处理完消息后手动给消息队列返回 ACK 确认，如果队列没收到则再次发送
